[TOP100高频算法训练营](https://www.bittiger.io/livecourses/66RhgaqQPgkWfGQcT)

今天早上听了一下试听课程，颇有收获！但是正在找工作，感觉时间上来不及（笔试已经接踵而来了。。

讲师：**冯沁原**

## 振聋发聩

1. 递归就是假设子问题已经完美求解
2. 动态规划本质 = 递归 + cache
3. 解题 3+1模板
    - 子问题拆解
    - 算法可视化
    - 打破假设
    - **寻找类比**

## 第一个观点

对于一个在此之前没有进行过算法训练的我来说这是拨云见日。

## 第二个观点

我是这样理解的：做算法题的时候使用**递归**和**cache**，这两个工具来解题。

但是，动态规划应该是：确定每个阶段的最优状态和之前阶段的状态之间的关系，然后用对应的方法编程实现（冯老师的观点，我认为是实现方法）。

> 怎么鉴定dp可解的一类问题需要从计算机是怎么工作的说起…计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，CPU只能利用当前的状态计算出下一个状态（不要纠结硬盘之类的外部存储，就算考虑他们也只是扩大了状态的存储容量而已，并不能改变下一个状态只能从当前状态计算出来这一条铁律）

> 阶段是指随着问题的解决，在同一个时刻可能会得到的不同状态的集合

斐波那契数列每个阶段只有一个状态，而下象棋每个阶段可以有多个状态！

> 每个阶段只有一个状态->递推；
> 每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
> 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
> 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。

[什么是动态规划？动态规划的意义是什么？王勐的回答](https://www.zhihu.com/question/23995189/answer/35429905)

## 第三个观点

应该说是结题模板。这里先列一下试听课所讲的**四道题**：

- 逆置链表 Reverse a linked list
- Happer number
- Perfect Square
- Binary tree vertical order traversal

#### 逆置链表

> 什么是挂掉95%面试者的简单题

冯老师这么形容这道题，所以我肯定会挂掉了QAQ

最大的收获

> 递归就是假设子问题已经完美求解

#### Happy number

68 -> 6^2 + 8^2 -> 100 -> 1^2 + 0^2 + 0^2 -> 1

像上面这样满足，将各个位的数平方之后加和，然后重复最后不再改变（为1）的性质的数就是`Happy number`.

那么，加入需要你判断一个`int`类型的数字`num`是不是`happy number`，应该怎么做？**时间复杂度**是多少？

`num`如果满足性质，最后得到`1`，不满足的话，最后会进入一个循环，这个循环中的每个数字都不是`happy number`.

**解题**：那就需要一个`set`，将`num`添加到`set`中。然后，计算`num`一次变换之后的下一个数，如果等于`1`，返回`true`；如果在`set`中已经存在这个元素，返回`false`；否则将这个数添加到`set`中继续执行。

###### 时间复杂度

要计算这个算法的时间复杂度，首先了解时间复杂度的概念。时间复杂度表示了问题规模对算法运行时间的影响程度。

如果，算法运行时间和问题规模没有关系，比如得到数组的第一个元素，那么时间复杂度就是`O(1)`，具有常数时间。二分搜索则具有对数复杂度，

> 对数时间的算法是非常有效的，因为每增加一个输入，其所需要的额外计算时间会变小。

那么，这道题的时间复杂度是多少呢？

如果`int`占四个字节，那么最大的整型是：`2^31-1 = 2147483647 < 9999999999`，而`10 x 9^2 = 810`。也就是说一步转化之后不管你多大的数都小于`810`，也就是说这个题算法时间复杂度应该是`O(1)`，空间复杂度也是这样。

###### BigData

那如果你是在做一个线上的判断，需要每次都调用一个下你写的函数么？

不需要。你需要建立一个表(num, true/false)，实现使用`map`这样的数据结构。那么，每次判断一个数字是不是满足性质，看表中有没有有该数字以及是不是`happy number`。如果没有，再调用你的算法，如果最后这个数字得到`true`，将`set`中的所有数字都添加到表中(num, true).如果该数字结果是`false`，同样`set`中的所有数字以`false`身份加入到表中。而你的表中最终只有不到`810`个条目。

当然，想这样你需要先进行一次变换，将数字压缩到`810`以内。

注：如果你的`int`占用的字节数是逐渐增大的，那就。。。

#### Perfect Square

求一个数最少可以由多少个数的完全平方加和组成。

例子：17 = 1^2 + 4^2，也就是所 17 在这道题中答案是 2. 好像数学有证明所有的数答案不超过 4（没有求证）。

###### 子问题拆解

`17 = 1^2+16 = 2^2+13 = 3^2+8 =...`

###### 算法可视化

`17`当作根节点，然后下面是很多分支，在纸上画出来会更有利于分析，而且可以用来检验方法是否正确。

其他，待续。。。

###### 打破假设

如果，你编程实现了你的算法，判断不同的数字的时候，会发现有的`num`可以`break`你当前设置的一些条件。

这里，不如如果一个数字等于两个数字完全平方的加和，那还用考虑其他的情况么？不同，那就要再算法中实现剪枝，来加快算法运行速度。

冯老师还举了一个栈他代码中给的栈溢出的示例，待续。。。

###### 寻找类比

拟解决了`Perfect Square`，那你能不能解决`Perfect cube: 7 = (-1)^3 + 2^3`呢？

#### Binary tree vertical order traversal

输出一个二叉树，从左到右，从上到下的遍历结果。

冯老师，在将这道题的时候直接给出了方法，根节点标记一个`0`，根节点的左子节点标记为`-1`，即`0`减`1`（向左走减一），根节点右子节点标记`+1`，递归标记。觉得，得到这样的想法也是一个思考的过程。这一步也算是子问题拆解了吧。

###### 算法可视化

那么，实现这样的算法，应该使用`BFS`、`DFS`还是`Both OK`呢？这时候可以用一个稍复杂的二叉树进行测试，比如：`9, 7, 3, -1, 4, -1, 5, -1, -1, 12, 10, -1, -1, 14, -1, -1`（这个循序的构建方法是先序构建二叉树，这个顺序构建后也满足一个二叉搜索数），通过可视化，可以检验`DFS`无法得到正确的结果。

因为要求，从左到右，从上到下遍历，`DFS`无法保证，树节点中处于同一列的按照从上到下的顺序遍历。

但是，如果你的可视化用例太简单，那就可能是`Both OK`.

###### 寻找类比

试一试三叉树的垂直遍历好了~

---

程序 = 数据结构 + 算法
