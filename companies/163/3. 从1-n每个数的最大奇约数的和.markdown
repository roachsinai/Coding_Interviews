思路：只需要知道一点，奇数的最大奇约数就是它本身

如果，一个数是偶数，那就除二知道变成奇数为止。当然，其实可以进行优化。

例如：

`1,2,3,4,5,6,7,8,9,10` 计算所有的奇数之和是 `1+3+5+7+9=25` 后，剩下的就是`2,4,6,8,10`，如果按照思路一的算法接下来需要循环每个数除 2 求值，所有数据除 2 以后就是 `1,2,3,4,5`，求奇数之和就是 `1+3+5=9`；剩余 `2,4`，再除以 2 就是`1,2`，求奇数之和就是 `1`；剩余 `2`，再除以 2 就是 `1`，求奇数之和就是 `1`；到此结束最后 `25+9+1+1=36`。我们把所有步骤格式化一下：

|当前队列|奇数求和|
|:---:|:---:|
|(1,2,3,4,5,6,7,8,9,10)|1+3+5+7+9=25|
|(2,4,6,8,10)/2=(1,2,3,4,5)|1+3+5=9|
|(2,4)/2=(1,2)|1=1|
|(2)/2=(1)|1=1|

结果 `25+9+1+1=36`。可以发现每层对立的结果都是一个完全平方数。

`code:`

```python
n = 10
ans = 0
while n > 0:
    if n % 2 == 0:
        t = (n * n) >> 2   # n 为偶数时求 1 - n 所有奇数和
    else:
        t = (n + 1) * (n + 1) >> 2   # n 为奇数时求 1 - n 所有奇数和
    ans += t
    n >>= 1
print('%d' % (ans))
```

## refs

1. [算法：1-N的最大奇数约数之和\_n+1 2n 最大奇因数 相加 n2-CSDN博客](https://blog.csdn.net/shuijinglingsos/article/details/103203649)
